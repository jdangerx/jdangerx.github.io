<!DOCTYPE html>
<html lang="en">
<head>
          <title>No Promises</title>
        <meta charset="utf-8" />
        <link href='http://fonts.googleapis.com/css?family=Vollkorn' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" type="text/css" href="/theme/css/base.css"/>
        <link href="http://www.johnxia.me/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="No Promises Full Atom Feed" />
        <link href="http://www.johnxia.me/feeds/rss.xml" type="application/rss+xml" rel="alternate" title="No Promises Full RSS Feed" />
        <link href="http://www.johnxia.me/feeds/planetaryclimate.atom.xml" type="application/atom+xml" rel="alternate" title="No Promises Categories Atom Feed" />




</head>

<body id="index" class="home">
  <div class="content">
        <header id="banner" class="body">
                <h1><a href="./">No Promises <strong></strong></a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
            <li><a href="/">projects</a></li>
            <li><a href="/archives.html">blog</a></li>
            <li><a href="/pages/about.html">about</a></li>
            <li><a href="http://www.github.com/jdangerx">github</a></li>
            <li><a href="/misc/resume.pdf">resume</a></li>
        </ul></nav><!-- /#menu -->
        <hr>
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="./principles-of-planetary-climate-chapter-1-workbook.html" rel="bookmark"
         title="Permalink to Principles of Planetary Climate, Chapter 1 Workbook">Principles of Planetary Climate, Chapter 1 Workbook</a></h2>
 
  </header>
  <footer class="post-info">
    <abbr class="published" title="2015-01-10T00:00:00-06:00">
      Sat 10 January 2015
    </abbr>
    <address class="vcard author">
      By           <a class="url fn" href="./author/john-xia.html">John Xia</a>
    </address>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<script type="text/javascript" src="path-to-mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<h1>Chapter 1 Workbook</h1>
<p>These are my solutions to the Chapter 1 problems of <a href="http://www.amazon.com/gp/product/0521865565/">Principles of
Planetary Climate</a>. I
make no claims as to their accuracy, but if you are interested in
seeing what I've done go right ahead.</p>
<p>First we have some imports and useful constants. Python doesn't have a
built-in sign function, so we have a simple implementation here
also. I've imported seaborn, which is an interesting graphing library
built on top of matplotlib. It does a lot of fancy things we don't
need, but importing it also makes all matplotlib graphs look nicer.</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">e</span><span class="p">,</span> <span class="kp">log2</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="kp">log</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="kn">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">romb</span><span class="p">,</span> <span class="n">quad</span><span class="p">,</span> <span class="n">odeint</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">InterpolatedUnivariateSpline</span>
<span class="kn">from</span> <span class="nn">scipy.misc</span> <span class="kn">import</span> <span class="n">derivative</span>


<span class="c"># gravitational constant</span>
<span class="n">G</span> <span class="o">=</span> <span class="mf">6.67e-11</span>

<span class="c"># mass of the earth</span>
<span class="n">M_e</span> <span class="o">=</span> <span class="mf">6e24</span>

<span class="c"># radius of earth, in m</span>
<span class="n">r_earth</span> <span class="o">=</span> <span class="mi">6378100</span>

<span class="c"># surface area of earth</span>
<span class="n">sa_e</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">r_earth</span><span class="o">**</span><span class="mi">2</span>

<span class="n">seconds_per_year</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">365</span>

<span class="c">#VSMOW</span>
<span class="n">O18_p_O16</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mf">498.7</span>  
<span class="n">D_p_H</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6420</span>


<span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>


<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
</pre></div>


<h3>Problem 1.</h3>
<p>This is pretty simple. We just need to plot a function. You can do
basic math on NumPy arrays, which is pretty sweet.</p>
<div class="highlight"><pre>def luminosity(ages, t0=4.6e9):
    return (1 / (1 + 0.4 * (1 - ages/t0)))

def problem1():
    ages = np.linspace(0, 5e9, 100)
    luminosities = luminosity(ages)
    plt.figure(figsize=(12,9))
    plt.title(&quot;Luminosity vs. age of the Sun&quot;)
    plt.plot(ages, luminosities)
    plt.xlabel(&quot;Age (billions of years)&quot;)
    plt.ylabel(&quot;Luminosity as a fraction of current day&quot;)

problem1()
</pre></div>


<p><img alt="png" src="images/ch1_files/ch1_3_0.png" /></p>
<h3>Problem 2.</h3>
<p>What was initially just a simple file IO example was complicated by
some interesting encoding issues. The Vostok ice core data was
unreadable with UTF-8. So I opened the file in Firefox - some of the
scientists' names were rendered improperly. I played with the encoding
until it worked - unfortunately it was just listed in Firefox as
"Western." I then looked up what possible encodings I could use and
used the one labeled "Western Europe."</p>
<p>Additionally the C CSV parsing engine was having issues using the
<code>delim_whitespace</code> option, so I had to specify the Python engine
instead. Fortunately this dataset was pretty small (about 3000 lines)
so the speed hit wasn't really important.</p>
<p>I thought that having a line connecting the data points hid the
decrease in data density as ice age increases, so I made it with
points instead.</p>
<div class="highlight"><pre>def problem2():
    vostokT = pd.read_csv(&quot;data/Chapter1Data/iceCores/vostokT.txt&quot;,
                          skiprows=115, 
                          encoding=&#39;iso8859_15&#39;, # &quot;Western&quot; encoding
                          delimiter=&#39;\s&#39;,
                          engine=&quot;python&quot;)
    plt.figure(figsize=(12,8))
    plt.title(&quot;Temperature change vs. ice age&quot;)
    plt.plot(vostokT.corrected_Ice_age_GT4, vostokT.deltaTS,
             marker=&quot;.&quot;, linestyle=&quot;none&quot;)
    plt.xlabel(&quot;Ice age (years)&quot;)
    plt.ylabel(&quot;Temperature difference from present (C)&quot;)
    plt.figure(figsize=(12,8))
    plt.title(&quot;Depth vs. ice age&quot;)
    plt.plot(vostokT.corrected_Ice_age_GT4, vostokT.Depth,
             marker=&quot;.&quot;, linestyle=&quot;none&quot;)
    plt.xlabel(&quot;Ice age (years)&quot;)
    plt.ylabel(&quot;Ice core depth (m)&quot;)
problem2()
</pre></div>


<p><img alt="png" src="images/ch1_files/ch1_5_0.png" /></p>
<p><img alt="png" src="images/ch1_files/ch1_5_1.png" /></p>
<h3>Problem 3.</h3>
<p>This was an exercise in doing arithmetic on columns of data. I wanted
to try the Pandas DataFrames out. In this example I'm just using them
as a dict to store NumPy arrays, but there's a bunch of other cool
stuff they can do. Later I find the standard deviation of a column
with a method call on the DataFrame, which is pretty slick.</p>
<p>The first plot is pretty silly but it is a nice example of how to do
arithmetic on arrays.</p>
<div class="highlight"><pre>def dry_adiabat(pressures):
    ground_temp = 300
    surface_pressure = 1000
    return ground_temp * (pressures/surface_pressure) ** (2/7)


def K_to_F(kelvins):
    return (kelvins - 273) * 1.8 + 32


def problem3a():
    pressures = np.arange(10, 1000)
    df = pd.DataFrame({&quot;pressures&quot;: pressures,
          &quot;dry_adiabat_K&quot;: dry_adiabat(pressures),
          &quot;dry_adiabat_F&quot;: K_to_F(dry_adiabat(pressures))})
    plt.figure(figsize=(12,8))
    plt.title(&quot;The dry adiabat vs. pressure&quot;)
    plt.ylabel(&quot;Temperature (degrees)&quot;)
    plt.xlabel(&quot;Pressure(mb)&quot;)
    plt.plot(df.pressures, df.dry_adiabat_K)
    plt.text(200, 160, &quot;Kelvin&quot;)
    plt.plot(df.pressures, df.dry_adiabat_F)
    plt.text(200, -150, &quot;Fahrenheit&quot;)


problem3a()
</pre></div>


<p><img alt="png" src="images/ch1_files/ch1_7_0.png" /></p>
<div class="highlight"><pre>def problem3b():
    gisstemp = pd.read_csv(&quot;data/Chapter1Data/GlobalWarming/GISSTemp.txt&quot;,
                           skiprows=28,
                           header=1,
                           encoding=&quot;utf-8&quot;,
                           na_values=&quot;*****&quot;,
                           delim_whitespace=True)
    avg_temps = gisstemp[&quot;J-D&quot;]/100 + 14
    season_diffs = (gisstemp.JJA - gisstemp.DJF)/100
    plt.figure(figsize=(12,9))
    plt.title(&quot;Global mean temperature vs. year&quot;)
    plt.xlabel(&quot;Year&quot;)
    plt.ylabel(&quot;Temperature (C)&quot;)
    plt.plot(gisstemp.Year, avg_temps)
    plt.figure(figsize=(12,9))
    plt.title(&quot;Change in strength of global seasonal cycle vs. year&quot;)
    plt.xlabel(&quot;Year&quot;)
    plt.ylabel(&quot;Temperature (C)&quot;)
    plt.plot(gisstemp.Year, season_diffs)

problem3b()
</pre></div>


<p><img alt="png" src="images/ch1_files/ch1_8_0.png" /></p>
<p><img alt="png" src="images/ch1_files/ch1_8_1.png" /></p>
<p>The temperature vs. year plot seems pretty reasonable. You get annual
fluctuations, and you see an upward trend that wouldn't be out of
place in a startup pitch deck.</p>
<p>The strength of the seasonal cycle seems to vary year-to-year as
well. There might be a slight downward trend - perhaps the southern
hemisphere winters are getting warmer? I think the variation is too
great to see a trend this small, but we could do some real analysis on
it if we wanted to dive deeper.</p>
<h3>Problem 4.</h3>
<p>Instead of writing my own polynomial interpolation function, I used
one out of SciPy. I found that
<code>scipy.interpolate.InterpolatedUnivariateSpline</code> is significantly
faster than <code>scipy.interpolate.interp1d</code>.</p>
<div class="highlight"><pre>def problem4():
    cubic = pd.DataFrame({&quot;x&quot;: [i for i in range(-2,3)],
                          &quot;y&quot;: [i**3 for i in range(-2, 3)]})
    interp_cubic = InterpolatedUnivariateSpline(cubic.x, cubic.y, k=3)
    xspace = np.linspace(min(cubic.x), max(cubic.x), 100)
    interp_cubic_df = pd.DataFrame({&quot;x&quot;: xspace,
                                    &quot;y&quot;: interp_cubic(xspace)})
    plt.figure(figsize=(12, 8))
    plt.title(&quot;Cubic interpolation from 5 data points&quot;)
    plt.plot(cubic.x, cubic.y, marker=&quot;.&quot;, linestyle=&quot;dashed&quot;)
    plt.plot(interp_cubic_df.x, interp_cubic_df.y)

    vostokT = pd.read_csv(&quot;data/Chapter1Data/iceCores/vostokT.txt&quot;,
                          skiprows=115, 
                          encoding=&#39;iso8859_15&#39;, # &quot;Western&quot; encoding
                          delimiter=&#39;\s&#39;,
                          engine=&quot;python&quot;)

    interp_deut = InterpolatedUnivariateSpline(vostokT.corrected_Ice_age_GT4,
                                               vostokT.deut)
    hundred_yr_intervals = np.arange(min(vostokT.corrected_Ice_age_GT4),
                                     max(vostokT.corrected_Ice_age_GT4),
                                     100)
    plt.figure(figsize=(12, 8))
    plt.title(&quot;Vostok ice core temperature vs. ice age,\n interpolated at 100 year intervals&quot;)
    plt.xlabel(&quot;Age (years)&quot;)
    plt.ylabel(&quot;Temperature (C)&quot;)
    plt.plot(hundred_yr_intervals, interp_deut(hundred_yr_intervals))

problem4()
</pre></div>


<p><img alt="png" src="images/ch1_files/ch1_11_0.png" /></p>
<p><img alt="png" src="images/ch1_files/ch1_11_1.png" /></p>
<h3>Problem 5</h3>
<p>This is where we use <code>sign</code>! This problem just asked to write some
root-finding algorithms. We see that Newton's method takes way fewer
steps to converge than the bisection method does -- 3 compared to 28.</p>
<div class="highlight"><pre>def func5(x):
    return x - e**(-x)


def bisect(interval, fn, iters=0, tol=1e-8):
    xbds = [interval[0], sum(interval)/2, interval[1]]
    while xbds[2] - xbds[0] &gt; xbds[1] * tol:
        iters += 1
        low, mid, hi = [fn(x) for x in xbds]
        if sign(low) == sign(hi):
            return None
        if sign(low) == sign(mid):
            xbds[0] = xbds[1]
        else:
            xbds[2] = xbds[1]
        xbds[1] = (xbds[0]+xbds[2])/2
    return (xbds[1], iters)


def newton(x0, fn, iters = 0, tol=1e-8, dx=1e-5):
    x1 = x0 - fn(x0)/derivative(fn, x0, dx=dx)
    while abs(x1 - x0) &gt; 1e-8:
        iters += 1
        x0 = x1
        x1 = x0 - fn(x0)/derivative(fn, x0, dx=dx)
    return ((x1 + x0)/2, iters)


def problem5():
    print(bisect((0, 1), func5))
    print(newton(0.5, func5))

problem5()

(0.5671432893723249, 28)
(0.56714329040978251, 3)
</pre></div>


<h3>Problem 6.</h3>
<p>I learned how to use the Romberg integration function,
<code>scipy.integrate.romb</code>! You need to make sure the number of samples is
one more than a power of two, so that's what the funky <code>ceil(log2(a))</code>
stuff is. Beyond that this is pretty straightforward. As expected, the
integral goes to 1 pretty quickly as a increases.</p>
<div class="highlight"><pre><span class="x">def gaussian(x):</span>
<span class="x">    return e ** (-x**2)</span>


<span class="x">def problem6():</span>
<span class="x">    plt.figure(figsize=(12,9))</span>
<span class="x">    aspace = np.linspace(0, 10, 200)</span>
<span class="x">    plt.title(&quot;Romberg integration of </span><span class="p">$</span><span class="nv">y</span><span class="x">=\int_0^ae^</span><span class="err">{</span><span class="x">-x^2}dx</span><span class="p">$</span><span class="x">\n&quot;, fontsize=24)</span>
<span class="x">    plt.ylabel(&quot;</span><span class="p">$</span><span class="nv">y</span><span class="p">$</span><span class="x">&quot;, fontsize=24)</span>
<span class="x">    plt.plot(aspace, [romb_of_a(a) for a in aspace])</span>
<span class="x">    plt.text(2, 0.8, r&quot;number of steps = </span><span class="p">$</span><span class="x">2^</span><span class="err">{</span><span class="x">\lceil log_2 a\rceil}\cdot32+1</span><span class="p">$</span><span class="x">&quot;,</span>
<span class="x">             fontsize=18)</span>
<span class="x">    plt.xlabel(&quot;</span><span class="p">$</span><span class="nv">a</span><span class="p">$</span><span class="x">&quot;, fontsize=24)</span>


<span class="x">def romb_of_a(a):</span>
<span class="x">    if a == 0:</span>
<span class="x">        return 0</span>
<span class="x">    xspace = np.linspace(0, a, 2**(5 + np.ceil(log2(a)))+1)</span>
<span class="x">    return romb(gaussian(xspace), xspace[1] -xspace[0])</span>


<span class="x">problem6()</span>
</pre></div>


<p><img alt="png" src="images/ch1_files/ch1_15_0.png" /></p>
<h3>Problem 7</h3>
<p>Instead of working hard and thinking about different numerical methods
for solving differential equations I just used <code>scipy.integrate.odeint</code>.</p>
<div class="highlight"><pre><span class="x">def diff_eq(a):</span>
<span class="x">    return (lambda y, t: a*y*(1-y))</span>

<span class="x">def problem7():</span>
<span class="x">    tscale = np.linspace(0, 10, 100)</span>
<span class="x">    plt.figure(figsize=(12, 8))</span>
<span class="x">    plt.text(3.6, 1.1, r&quot;</span><span class="p">$</span><span class="x">\frac</span><span class="err">{</span><span class="x">dY}</span><span class="err">{</span><span class="x">dt} = aY\cdot(1-Y)</span><span class="p">$</span><span class="x">&quot;, fontsize=24)</span>
<span class="x">    plt.plot(tscale, odeint(diff_eq(1), 0.01, tscale))</span>
<span class="x">    plt.text(5, 0.5, r&quot;</span><span class="p">$</span><span class="nv">a</span><span class="x">=1</span><span class="p">$</span><span class="x">&quot;, fontsize=16)</span>
<span class="x">    plt.plot(tscale, odeint(diff_eq(2), 0.01, tscale))</span>
<span class="x">    plt.text(2.5, 0.5, r&quot;</span><span class="p">$</span><span class="nv">a</span><span class="x">=2</span><span class="p">$</span><span class="x">&quot;, fontsize=16)</span>
<span class="x">    plt.plot(tscale, odeint(diff_eq(3), 0.01, tscale))</span>
<span class="x">    plt.text(1.65, 0.5, r&quot;</span><span class="p">$</span><span class="nv">a</span><span class="x">=3</span><span class="p">$</span><span class="x">&quot;, fontsize=16)</span>
<span class="x">    plt.plot(tscale, odeint(diff_eq(4), 0.01, tscale))</span>
<span class="x">    plt.text(0.6, 0.5, r&quot;</span><span class="p">$</span><span class="nv">a</span><span class="x">=4</span><span class="p">$</span><span class="x">&quot;, fontsize=16)</span>
<span class="x">    plt.xlabel(&quot;time (t)&quot;)</span>

<span class="x">problem7()</span>
</pre></div>


<p><img alt="png" src="images/ch1_files/ch1_17_0.png" /></p>
<h3>Problem 8.</h3>
<p>Here I use a <a href="http://wiki.scipy.org/Cookbook/Zombie_Apocalypse_ODEINT">cool trick from the SciPy
cookbook</a> by
turning two differential equations into one differential equation
which acts on a 2D vector, making it really easy to pitch to <code>odeint</code>.</p>
<div class="highlight"><pre><span class="x">def func8(xs, t):</span>
<span class="x">    y = xs[0]</span>
<span class="x">    z = xs[1]</span>
<span class="x">    fy = - z/(y**2 + z**2)</span>
<span class="x">    fz = y/(y**2 + z**2)</span>
<span class="x">    return [fy, fz]</span>


<span class="x">def problem8():</span>
<span class="x">    y0 = 1</span>
<span class="x">    z0 = 0</span>
<span class="x">    tscale = np.linspace(0, 10, 100)</span>
<span class="x">    sol = odeint(func8, [y0, z0], tscale).transpose()</span>
<span class="x">    plt.figure(figsize=(12, 8))</span>
<span class="x">    plt.plot(tscale, sol[0])</span>
<span class="x">    plt.text(1.7, 0, r&quot;</span><span class="p">$</span><span class="nv">Y</span><span class="p">$</span><span class="x">&quot;, fontsize=24)</span>
<span class="x">    plt.text(0.1, -0.5, r&quot;</span><span class="p">$</span><span class="nv">dY</span><span class="x">/dt = -\frac</span><span class="err">{</span><span class="x">Z}</span><span class="err">{</span><span class="x">Y^2+Z^2}</span><span class="p">$</span><span class="x">&quot;, fontsize=18)</span>
<span class="x">    plt.plot(tscale, sol[1])</span>
<span class="x">    plt.text(3.4, 0, r&quot;</span><span class="p">$</span><span class="nv">Z</span><span class="p">$</span><span class="x">&quot;, fontsize=24)</span>
<span class="x">    plt.text(2.8, 0.5, r&quot;</span><span class="p">$</span><span class="nv">dZ</span><span class="x">/dt = \frac</span><span class="err">{</span><span class="x">Y}</span><span class="err">{</span><span class="x">Y^2+Z^2}</span><span class="p">$</span><span class="x">&quot;, fontsize=18)</span>
<span class="x">    plt.xlabel(&quot;time (t)&quot;)</span>


<span class="x">problem8()</span>
</pre></div>


<p><img alt="png" src="images/ch1_files/ch1_19_0.png" /></p>
<h3>Problem 9.</h3>
<p>Now begins a series of increasingly interesting basic physics and
chemistry problems.</p>
<p>In this one we calculate the amount of energy that comes into the
Earth from the Sun. We find that this is enough to raise our entire
atmosphere off the Earth pretty quickly. This hasn't happened yet
because a lot of the energy coming from the Sun ends up warming the
Earth. Then this energy just gets radiated out again. This leaves
little room for lifting our atmosphere.</p>
<div class="highlight"><pre>def grav_pot(r):
    &quot;Get gravitational potential at a radius from the Earth.&quot;
    return -G*M_e/r

def problem9():
    weight = 10 # 10 m/s^2 * 1 kg = 10N
    print(&quot;The weight of a 1kg object on the surface of the Earth is &quot;
          &quot;10 newtons.&quot;)
    joules_per_kg_100m = 1000 # 10N * 100m = 1000J
    print(&quot;It takes 1000 joules to raise a 1kg mass 100m.&quot;)
    insolation = sa_e * 200
    print(&quot;The total insolation of the Earth is about {:.2e} watts.&quot;.format(
               insolation))
    delta_U = 1e4 * (grav_pot(2e5+r_earth) - grav_pot(r_earth)) # for 1 m^2

    num_sec = delta_U / 200
    print(&quot;It would take {:.2e} seconds, or {:.2f} years, to lift all parts &quot;
          &quot;of the atmosphere 200 km.&quot;.format(num_sec, num_sec/seconds_per_year))
    delta_U_mgh = 1e4 * 10 * 2e5
    num_sec_mgh = delta_U_mgh / 200

    print(&quot;If we assume that gravitational acceleration is independent of &quot;
          &quot;position we find that it would take {:.2f} years.&quot;.format(
              num_sec_mgh/seconds_per_year))


problem9()

The weight of a 1kg object on the surface of the Earth is 10 newtons.
It takes 1000 joules to raise a 1kg mass 100m.
The total insolation of the Earth is about 1.02e+17 watts.
It would take 9.54e+07 seconds, or 3.02 years, to lift all parts of the atmosphere 200 km.
If we assume that gravitational acceleration is independent of position we find that it would take 3.17 years.
</pre></div>


<h3>Problem 10.</h3>
<p>A quick calculation of the kinetic energy of a comet with a mass of $4
\cdot 10^9$ kg and velocity of $1 \cdot 10^4$ m/s.</p>
<div class="highlight"><pre>def problem10():
    # mv^2 / 2
    K = 4e9 * 1e4 ** 2 / 2
    print(&quot;The comet turns {} joules of kinetic energy into heat (and a little &quot;
          &quot;kinetic energy for the flying debris).&quot;.format(K))
problem10()


The comet turns 2e+17 joules of kinetic energy into heat (and a little kinetic energy for the flying debris).
</pre></div>


<h3>Problem 11.</h3>
<p>We use Newton's law of gravitation to determine the mass of a body as
a function of its radius and surface gravitational
acceleration. Here's the derivation:</p>
<p>$$U = -\frac{GmM}{r}$$
$$\frac{\mathrm{d}U}{\mathrm{d}r} = \frac{GmM}{r^2} = ma$$
$$M = \frac{ar^2}{G}$$</p>
<div class="highlight"><pre>def problem11():
    r_titan = 2.575e6
    a_titan = 1.35
    a_earth = 9.8
    mass_titan = r_titan**2 * a_titan / G
    mass_earth = r_earth**2 * a_earth / G
    print(&quot;The mass of Titan is {:.3} kg.&quot;.format(mass_titan))
    print(&quot;In comparison, the mass of Earth is {:.2} kg.&quot;.format(mass_earth))

problem11()

The mass of Titan is 1.34e+23 kg.
In comparison, the mass of Earth is 6e+24 kg.
</pre></div>


<h3>Problem 12.</h3>
<p>A quick calculation of the potential energy of the Moon, and a
reminder that heavier things do not, in fact, fall faster. Could
Aristotle do this? I think not.</p>
<div class="highlight"><pre>def problem12():
    m_moon = 7.35e22
    r_moon = 3.84e8
    K_moon = U_moon = m_moon*(-1 * grav_pot(r_moon))
    print(&quot;The kinetic energy of the Moon on impact would be {:.2} J.&quot;.format(K_moon))
    v_f = (2*grav_pot(r_moon))**0.5
    print(&quot;The final velocity of the Moon is {:.2} m/s and does not depend on &quot;
          &quot;the mass of the Moon.&quot;.format(v_f))


problem12()

The kinetic energy of the Moon on impact would be 7.7e+28 J.
The final velocity of the Moon is (8.8e-14+1.4e+03j) m/s and does not depend on the mass of the Moon.
</pre></div>


<h3>Problem 13.</h3>
<p>If an impactor the size of the Moon hits the earth at 15,000 m/s, will
it vaporize?</p>
<p>Another gentle reminder that mass divides out all the time when you
are dealing with gravitational potential energy.</p>
<div class="highlight"><pre>def problem13():
    m_moon = 7.35e22
    K_over_m = 0.5 * 1.5e4 ** 2  # 1/2 v^2
    K = m_moon * K_over_m
    vaporization_energy = 2e7
    print(&quot;The kinetic energy released by the impact is {:.2} J.&quot;.format(K))
    print(&quot;This is {:.2} J/kg.&quot;.format(K_over_m))
    if K_over_m &lt; vaporization_energy:
        print(&quot;This is not enough to vaporize the impactor.&quot;)
    else:
        print(&quot;This is enough to vaporize the impactor.&quot;)


problem13()

The kinetic energy released by the impact is 8.3e+30 J.
This is 1.1e+08 J/kg.
This is enough to vaporize the impactor.
</pre></div>


<h3>Problem 1.14.</h3>
<p>We have
$$M(\mathcal{L}_\circledast, d) = C-2.5\log_{10}\frac{\mathcal{L}_\circledast}{4\pi d^2}$$
where $M$ is bolometric magnitude, $L_\circledast$ is luminosity of a star, $d$
is the distance between that star and the observer, and $C$ a constant that
makes the magnitude of Vega from Earth about 0.</p>
<p>Taking $r_0$ to be the average distance of the Earth from the Sun we have
$$M_0 = C - 2.5\log{10}\frac{\mathcal{L}_\odot}{4\pi r_0^2}$$
where $M_0$ is the bolometric magnitude of the Sun as seen from Earth.</p>
<p>Subtracting the two we get
$$M_0 - M = 2.5 (\log{10} \frac{\mathcal{L}_\circledast}{4\pi d^2} -\log_{10}
\frac{\mathcal{L}_\odot}{4\pi r_0^2})$$</p>
<p>$$\frac{M_0-M}{2.5} = \log_{10} \frac{\mathcal{L}_\circledast
r_0^2}{\mathcal{L}_\odot d^2}$$
$$\mathcal{L}_\circledast = \mathcal{L}_\odot(\frac{d}{r_0})^2
10^{\frac{M_0-M}{2.5}}$$</p>
<p>Which makes sense - we see that as $M$ decreases, $\mathcal{L}_\circledast$
increases. All else held constant, lower bolometric magnitude should imply a
more luminous star. Additionally the implied luminosty increases as
$\frac{d}{r_0}$ increases if magnitude is held constant. We also see that the
units are the same on both sides of the equation, which is an encouraging sign.
Now plugging the Gliese 581 numbers in, we get:</p>
<div class="highlight"><pre>sun_lum = 3.846e26
M_0 = -26.82
r_0 = 1.496e11
m_per_parsec = 3.086e16


def bolometric(luminosity, dist):
    return -18.98 - 2.5*log(luminosity/(4*pi*dist**2), 10)


def lum_mag_dist(magnitude, dist):
    return sun_lum * (dist/r_0) **2 * 10**((M_0 - magnitude)/2.5)


def dist(magnitude, luminosity):
    return (luminosity * r_0**2 / sun_lum * 10**((magnitude - M_0)/2.5)) ** 0.5


gliese_lum = lum_mag_dist(8.12, 6.27*m_per_parsec)
print(&quot;We need to be {:.2e} m from Gliese 581 for it to have the same apparent &quot;
      &quot;magnitude as the Sun on Earth.&quot;.format(dist(M_0, gliese_lum)))
print(&quot;We need to be {:.2e} m from the Sun for it to have the same apparent &quot;
      &quot;magnitude as the Sun on Earth.&quot;.format(dist(M_0, sun_lum)))
print(&quot;We need to be {:.2e} m from the Sun for it to have the same apparent &quot;
      &quot;magnitude as Gliese 581 from Earth.&quot;.format(dist(8.12, sun_lum)))
print(&quot;We need to be {:.2e} m from Gliese 581 for it to have the same apparent &quot;
      &quot;magnitude as Gliese 581 from Earth.&quot;.format(dist(8.12, gliese_lum)))


We need to be 1.99e+10 m from Gliese 581 for it to have the same apparent magnitude as the Sun on Earth.
We need to be 1.50e+11 m from the Sun for it to have the same apparent magnitude as the Sun on Earth.
We need to be 1.46e+18 m from the Sun for it to have the same apparent magnitude as Gliese 581 from Earth.
We need to be 1.93e+17 m from Gliese 581 for it to have the same apparent magnitude as Gliese 581 from Earth.
</pre></div>


<p>We would need to be orbiting at $1.99\times10^{10}$ m from Gliese 581
to get the same stellar flux as we do here on Earth.</p>
<p>Since flux varies as $r^2\mathcal{L}$, we could also have reached this
conclusion by finding the square root ratio of the luminosities and
multiplying that by Earth's orbital radius:</p>
<p>$$r = r_0\sqrt{\frac{\mathcal{L}_\circledast}{\mathcal{L}_\odot}}$$ </p>
<p>Where $r$ is the orbital radius of a planet in the Gliese 581 system.</p>
<p>Incidentally, <a href="http://en.wikipedia.org/wiki/Gliese_581">Wikipedia</a>
states that Gliese 581's apparent magnitude is between 10.56 and
10.58. Implications of this are left for the reader ;).</p>
<p>To find the absolute magnitude we just need to use the functions
defined above (or we can go straight to the flux):</p>
<div class="highlight"><pre>def abs_mag(magnitude, dist):
    lum = lum_mag_dist(magnitude, dist)
    flux = lum/(4*pi*(10*m_per_parsec)**2)
    return -18.98 - 2.5 * log(flux, 10)

print(&quot;The absolute magnitude of the Sun is {:.2f}.&quot;.format(abs_mag(M_0, r_0)))
print(&quot;The absolute magnitude of Gliese 581 is {:.2f}.&quot;
      .format(abs_mag(8.12, 6.27*m_per_parsec)))

The absolute magnitude of the Sun is 4.75.
The absolute magnitude of Gliese 581 is 9.13.
</pre></div>


<p>The apparent magnitude of the Sun listed on Wikipedia is also slightly
higher than that found here.</p>
<h3>Problem 1.15</h3>
<p>To find the hydrogen-burning lifetime of a star based on its
luminosity and mass, we first let $\mathcal{L}$ be luminosity, $E_f$
be energy per fusion, $m_f$ be mass per fusion, $M$ be mass of the
stellar core and $t_f$ be the time of final hydrogen fusion. Assuming
the star is completely hydrogen, we get:</p>
<p>$$M = \int_0^{t_f} \mathcal{L}\frac{m_f}{E_f}\mathrm{d}t$$.</p>
<p>If we assume $\mathcal{L}$ is constant, we get</p>
<p>$$M = \frac{\mathcal{L}m_f}{E_f}t$$
$$t = \frac{ME_f}{\mathcal{L}m_f}$$</p>
<p>However, we know that $\mathcal{L}$ actually varies with time, roughly
according to Eq. 1.1:</p>
<p>$$\mathcal{L}(t) = L_{t_\odot}(1+\frac{2}{5}(1-\frac{t}{t_\odot}))^{-1}$$</p>
<p>Which we can plug into the integral above:</p>
<p>$$M=\frac{\mathcal{L_\odot}m_f}{E_f}\int_0^{t_f}(1+\frac{2}{5}(1-\frac{t}{t_\odo
t}))^{-1}\mathrm{d}t$$</p>
<p>Let's take $t_\odot = \frac{t_f}{2}$, as recommended by the text -
this somewhat eases our minds about using this approximation far away
from $t_\odot$. After some $u$-substitution we can get</p>
<p>$$M=\frac{5\mathcal{L_\odot}m_ft_f}{4E_f}\ln\frac{7}{3}$$
$$t_f=\frac{4E_fM}{5\mathcal{L_\odot}m_f\ln\frac{7}{3}}$$</p>
<p>Now to answer the questions we just need to implement these equations
in code, keeping in mind that about 10% of the mass of a star actually
undergoes fusion.</p>
<div class="highlight"><pre><span class="nx">def</span> <span class="nx">mass_remaining</span><span class="p">(</span><span class="nx">initmass</span><span class="p">,</span> <span class="nx">luminosity</span><span class="p">,</span> <span class="nx">time</span><span class="p">)</span><span class="o">:</span>
    <span class="s2">&quot;Luminosity needs to be a function taking time as a parameter.&quot;</span>
    <span class="nx">proton_mass</span> <span class="o">=</span> <span class="mf">1.67</span><span class="nx">e</span><span class="o">-</span><span class="mi">27</span>
    <span class="nx">mass_p_fusion</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="nx">proton_mass</span>
    <span class="nx">energy_p_fusion</span> <span class="o">=</span> <span class="mf">4.17</span><span class="nx">e</span><span class="o">-</span><span class="mi">12</span>
    <span class="nx">burned</span> <span class="o">=</span> <span class="nx">quad</span><span class="p">(</span><span class="nx">luminosity</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">time</span><span class="p">)</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span> <span class="o">*</span> <span class="nx">mass_p_fusion</span> <span class="o">/</span> <span class="nx">energy_p_fusion</span>
    <span class="k">return</span> <span class="nx">initmass</span> <span class="o">-</span> <span class="nx">burned</span>


<span class="nx">def</span> <span class="nx">findzero</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">init</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">bd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">:</span>
    <span class="nx">init_sign</span> <span class="o">=</span> <span class="nx">sign</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="nx">init</span><span class="p">))</span>
    <span class="nx">bd_sign</span> <span class="o">=</span> <span class="nx">sign</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="nx">bd</span><span class="p">))</span>
    <span class="k">while</span> <span class="nx">init_sign</span> <span class="o">==</span> <span class="nx">bd_sign</span><span class="o">:</span>
        <span class="nx">init</span> <span class="o">=</span> <span class="nx">bd</span>
        <span class="nx">bd</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="nx">init_sign</span> <span class="o">=</span> <span class="nx">sign</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="nx">init</span><span class="p">))</span>
        <span class="nx">bd_sign</span> <span class="o">=</span> <span class="nx">sign</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="nx">bd</span><span class="p">))</span>
    <span class="k">return</span> <span class="nx">bisect</span><span class="p">(</span><span class="cp">[</span><span class="nx">init</span><span class="p">,</span><span class="nx">bd</span><span class="cp">]</span><span class="p">,</span> <span class="nx">func</span><span class="p">)</span>


<span class="nx">def</span> <span class="nx">const_lum_lifetime</span><span class="p">(</span><span class="nx">initmass</span><span class="o">=</span><span class="mi">2</span><span class="nx">e29</span><span class="p">,</span> <span class="nx">lum</span><span class="o">=</span><span class="mi">4</span><span class="nx">e26</span><span class="o">*</span><span class="nx">seconds_per_year</span><span class="p">)</span><span class="o">:</span>
    <span class="k">return</span> <span class="nx">findzero</span><span class="p">(</span><span class="nx">lambda</span> <span class="nx">t</span><span class="o">:</span> <span class="nx">mass_remaining</span><span class="p">(</span><span class="nx">initmass</span><span class="p">,</span>
                                             <span class="nx">lambda</span> <span class="nx">t_l</span><span class="o">:</span> <span class="nx">lum</span><span class="p">,</span>
                                             <span class="nx">t</span><span class="p">))</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span>

<span class="nx">def</span> <span class="nx">var_lum_lifetime</span><span class="p">(</span><span class="nx">initmass</span><span class="o">=</span><span class="mi">2</span><span class="nx">e29</span><span class="p">,</span> <span class="nx">lum</span><span class="o">=</span><span class="mi">4</span><span class="nx">e26</span><span class="o">*</span><span class="nx">seconds_per_year</span><span class="p">)</span><span class="o">:</span>
    <span class="k">return</span> <span class="nx">findzero</span><span class="p">(</span><span class="nx">lambda</span> <span class="nx">t_0</span><span class="o">:</span> <span class="nx">mass_remaining</span><span class="p">(</span><span class="nx">initmass</span><span class="p">,</span>
                                               <span class="nx">lambda</span> <span class="nx">t_l</span><span class="o">:</span> <span class="nx">lum</span> <span class="o">*</span> <span class="nx">luminosity</span><span class="p">(</span><span class="nx">t_l</span><span class="p">,</span> <span class="nx">t_0</span><span class="p">),</span>
                                               <span class="nx">t_0</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
                    <span class="nx">init</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span><span class="o">*</span><span class="mi">2</span>


<span class="nx">def</span> <span class="nx">problem15a</span><span class="p">()</span><span class="o">:</span>
    <span class="nx">print</span><span class="p">(</span><span class="s2">&quot;Assuming constant luminosity of 4e26 W, a star with mass 2e30 kg has a &quot;</span>
          <span class="s2">&quot;lifetime of {:.2} y.&quot;</span><span class="p">.</span><span class="nx">format</span><span class="p">(</span><span class="nx">const_lum_lifetime</span><span class="p">()))</span>
    <span class="nx">print</span><span class="p">(</span><span class="s2">&quot;Assuming variable luminosity of 4e26 W halfway through its Main Sequence,&quot;</span>
          <span class="s2">&quot; a star with mass 2e30 kg has a lifetime of {:.2} y.&quot;</span>
          <span class="p">.</span><span class="nx">format</span><span class="p">(</span><span class="nx">var_lum_lifetime</span><span class="p">()))</span>
    <span class="nx">mass_scale</span> <span class="o">=</span> <span class="nx">np</span><span class="p">.</span><span class="nx">linspace</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>  <span class="err">#</span> <span class="nx">ratio</span> <span class="nx">to</span> <span class="nx">solar</span> <span class="nx">mass</span>
    <span class="nx">plt</span><span class="p">.</span><span class="nx">figure</span><span class="p">(</span><span class="nx">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
    <span class="nx">plt</span><span class="p">.</span><span class="nx">plot</span><span class="p">(</span><span class="nx">mass_scale</span><span class="p">,</span> <span class="cp">[</span><span class="nx">const_lum_lifetime</span><span class="p">(</span><span class="n">initmass</span><span class="o">=</span><span class="nx">m</span><span class="o">*</span><span class="mi">2</span><span class="nx">e29</span><span class="p">,</span>
                                             <span class="n">lum</span><span class="o">=</span><span class="mi">4</span><span class="nx">e26</span><span class="o">*</span><span class="nx">seconds_per_year</span><span class="o">*</span><span class="nx">m</span><span class="o">**</span><span class="p">(</span><span class="mf">3.5</span><span class="p">))</span> <span class="nx">for</span> <span class="n">m</span> <span class="k">in</span> <span class="nx">mass_scale</span><span class="cp">]</span><span class="p">)</span>
    <span class="nx">plt</span><span class="p">.</span><span class="nx">plot</span><span class="p">(</span><span class="nx">mass_scale</span><span class="p">,</span> <span class="cp">[</span><span class="nx">var_lum_lifetime</span><span class="p">(</span><span class="n">initmass</span><span class="o">=</span><span class="nx">m</span><span class="o">*</span><span class="mi">2</span><span class="nx">e29</span><span class="p">,</span>
                                           <span class="n">lum</span><span class="o">=</span><span class="mi">4</span><span class="nx">e26</span><span class="o">*</span><span class="nx">seconds_per_year</span><span class="o">*</span><span class="nx">m</span><span class="o">**</span><span class="p">(</span><span class="mf">3.5</span><span class="p">))</span> <span class="nx">for</span> <span class="n">m</span> <span class="k">in</span> <span class="nx">mass_scale</span><span class="cp">]</span><span class="p">)</span>
    <span class="nx">plt</span><span class="p">.</span><span class="nx">title</span><span class="p">(</span><span class="s2">&quot;The dependence of stellar lifetime on stellar mass,\n&quot;</span>
              <span class="s2">&quot;assuming constant luminosity&quot;</span><span class="p">)</span>
    <span class="nx">plt</span><span class="p">.</span><span class="nx">xlabel</span><span class="p">(</span><span class="s2">&quot;Mass ($M_\odot$)&quot;</span><span class="p">)</span>
    <span class="nx">plt</span><span class="p">.</span><span class="nx">ylabel</span><span class="p">(</span><span class="s2">&quot;Time ($10^{10}$y)&quot;</span><span class="p">)</span>

<span class="nx">problem15a</span><span class="p">()</span>


<span class="nx">Assuming</span> <span class="nx">constant</span> <span class="nx">luminosity</span> <span class="nx">of</span> <span class="mi">4</span><span class="nx">e26</span> <span class="nx">W</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">star</span> <span class="kd">with</span> <span class="nx">mass</span> <span class="mi">2</span><span class="nx">e30</span> <span class="nx">kg</span> <span class="nx">has</span> <span class="nx">a</span> <span class="nx">lifetime</span> <span class="nx">of</span> <span class="mf">9.9</span><span class="nx">e</span><span class="o">+</span><span class="mi">09</span> <span class="nx">y</span><span class="p">.</span>
<span class="nx">Assuming</span> <span class="nx">variable</span> <span class="nx">luminosity</span> <span class="nx">of</span> <span class="mi">4</span><span class="nx">e26</span> <span class="nx">W</span> <span class="nx">halfway</span> <span class="nx">through</span> <span class="nx">its</span> <span class="nx">Main</span> <span class="nx">Sequence</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">star</span> <span class="kd">with</span> <span class="nx">mass</span> <span class="mi">2</span><span class="nx">e30</span> <span class="nx">kg</span> <span class="nx">has</span> <span class="nx">a</span> <span class="nx">lifetime</span> <span class="nx">of</span> <span class="mf">9.3</span><span class="nx">e</span><span class="o">+</span><span class="mi">09</span> <span class="nx">y</span><span class="p">.</span>
</pre></div>


<p><img alt="png" src="images/ch1_files/ch1_36_1.png" /></p>
<p>We see that the radiation flux of the surface of a star is:</p>
<p>$$F_{out} = 5.67\cdot10^{-8}T^4$$</p>
<p>So the luminosity is given by</p>
<p>$$\mathcal{L} = F_{out}4\pi r^2 = 5.67cdot10^{-8}T^4\cdot4\pi r^2$$</p>
<p>And the surface temperature is given by</p>
<p>$$T=(\frac{\mathcal{L}}{5.67\cdot10^{-8}\cdot4\pi r^2})^{\frac{1}{4}}$$</p>
<p>Ignoring the compressibility of the star, its mass should vary as
$m = \frac{4}{3}\pi r^3 \Rightarrow r = (\frac{3m}{4})^{\frac{1}{3}} $.</p>
<p>So its temperature varies by</p>
<p>$$T=\Bigg(\frac{\mathcal{L}}{5.67\cdot10^{-8}\cdot4\pi
(\frac{3M_\circledast}{4})^{\frac{2}{3}}}\Bigg)^{\frac{1}{4}}$$</p>
<p>Since $\mathcal{L} \propto M_\circledast^{3.5}$ (Eq 1.2) we have</p>
<p>$$T=\Bigg(\frac{M_\circledast^{3.5}}{5.67\cdot10^{-8}\cdot4\pi
(\frac{3M_\circledast}{4})^{\frac{2}{3}}}\Bigg)^{\frac{1}{4}}$$</p>
<p>And as $T$ increases we see that $M_\circledast$ must increase, which as we saw
earlier, means that the lifetime of the star decreases.</p>
<h3>Problem 16.</h3>
<p>What's the power density of the Sun compared to that of a human?</p>
<p>How much hydrogen would I need for my entire lifetime if we ran of fusion?</p>
<p>With a bit of simple math we can get a decent feel for these things.</p>
<div class="highlight"><pre>def problem16():
    sun_lum = 3.84e26
    sun_core_mass = 1.99e29
    sun_power_density = sun_lum / sun_core_mass
    human_power = 1e2
    human_mass = 70
    human_power_density = human_power / human_mass
    print(&quot;A human uses about {:.2} watts/kg while the Sun uses {:.2} watts/kg.&quot;
          .format(human_power_density, sun_power_density))

    proton_mass = 1.67e-27
    mass_p_fusion = 4 * proton_mass
    energy_p_fusion = 4.17e-12
    energy_p_kg = energy_p_fusion / mass_p_fusion
    seconds_p_year = 365*24*60*60
    human_lifetime_energy = human_power * seconds_p_year * 80
    print(&quot;If a human ran on hydrogen fusion it would need {:.2} kg of hydrogen&quot;
          &quot; for a lifetime supply of energy.&quot;
          .format(human_lifetime_energy/energy_p_kg))

problem16()


A human uses about 1.4 watts/kg while the Sun uses 0.0019 watts/kg.
If a human ran on hydrogen fusion it would need 0.0004 kg of hydrogen for a lifetime supply of energy.
</pre></div>


<h3>Problem 17.</h3>
<p>How much calcite does 1 Gt of carbon turn into? What kind of volume are we
talking here?</p>
<div class="highlight"><pre>def problem17():
    CaCO3_mass = 100.09
    C_mass = 12.01
    CaCO3_p_C = CaCO3_mass / C_mass
    area_KS = 2.13e5
    CaCO3_density = 2700 * 1e-12  # Gt/m^3
    print(&quot;Each Gt of C, turned into CaCO3, is {:.2} Gt.&quot;.format(CaCO3_p_C))
    print(&quot;This amount would cover Kansas in a layer {:.2} m thick.&quot;
          .format(CaCO3_p_C/CaCO3_density/area_KS))

problem17()

Each Gt of C, turned into CaCO3, is 8.3 Gt.
This amount would cover Kansas in a layer 1.4e+04 m thick.
</pre></div>


<h3>Problem 18.</h3>
<p>What does 9 Gt of additional carbon in the form of $\mathrm{CO}_2$
mean, in terms of molecule count and atmospheric concentration?</p>
<div class="highlight"><pre>def problem18():
    CO2_mass = 44.01
    avogadro = 6.02e23
    C_mass = 12.01
    total_CO2_mass = CO2_mass / C_mass * 9e15 # 9 Gt of carbon in grams
    total_CO2_number = total_CO2_mass / CO2_mass * avogadro
    atmosphere_n = 1e44
    print(&quot;9 Gt carbon emissions is {:.2} CO2 molecules, which is {:.2}ppm.&quot;
          .format(total_CO2_number, total_CO2_number/atmosphere_n * 1e6))

problem18()


9 Gt carbon emissions is 4.5e+38 CO2 molecules, which is 4.5ppm.
</pre></div>


<h3>Problem 19.</h3>
<p>Some basic $\delta$ calculations.</p>
<div class="highlight"><pre>def problem19():
    return((1-0.037)*O18_p_O16,
           (1-0.438)*D_p_H)
problem19()





(0.0019310206536996193, 8.753894080996886e-05)
</pre></div>


<p>So we see that in ice with $\delta^{18}\mathrm{O}$ of -37 permil the
ratio of $^{18}\mathrm{O}$ to $^{16}\mathrm{O}$ is 0.0019.
We also see that in ice with $\delta\mathrm{D}$ of -438 permil the
ratio of $\mathrm{D}$ to $\mathrm{H}$ is $8.75\cdot10^{-5}$.</p>
<h3>Problem 20.</h3>
<p>What happens when you remove 300 m of the oceans' depth and freeze it
all in a glacier with $\delta\mathrm{D}$ of -420 permil?</p>
<p>$$(1+\delta_1)f_1+(1+\delta_2)f_2=1$$
$$\delta_2 = \frac{1-(1+\delta_1)f_1}{f_2} - 1$$</p>
<p>And $f_2 = 1-f_1$ so
$$\delta_2 = \frac{1-(1+\delta_1)f_1}{1-f_1} - 1$$</p>
<div class="highlight"><pre>def problem20():
    ocean_vol = 1.4e18  # m^3
    ocean_sa = 3.6e14  # m^2
    removed_frac = 300 * ocean_sa / ocean_vol
    removed_dD = -0.42
    remaining_dD = (1-(1+removed_dD)*removed_frac)/(1-removed_frac) -1
    return remaining_dD

problem20()





0.03510835913312693
</pre></div>


<p>So if we removed 300 m depth of ocean water to form an Antarctic
glacier with $\delta\mathrm{D}$ of -420 permil this would increase the
$\delta\mathrm{D}$ of the ocean water by 35 permil.</p>
<h3>Problem 21.</h3>
<p>We have</p>
<p>$$r_1 = (1 + \epsilon) r_2$$</p>
<p>And for any $i$, with $r_s$ the isotopic ratio of some standard,</p>
<p>$$r_i = (1 + \delta_i) r_s$$</p>
<p>Plugging this in we get</p>
<p>$$(1+\delta_1)r_s = (1+\epsilon) (1+\delta_2) r_s$$
$$1+\delta_1 = 1 + \delta_2 + \epsilon\, (1 + \delta_2)$$
$$\delta_1 - \delta_2 = (1+\delta_2)\, \epsilon$$
$$\blacksquare$$</p>
<p>At 290 K the $\delta^{18}\mathrm{O}$ of water vapor in equilibrium with liquid
with $\delta^{18}\mathrm{O}$ of 0 is -10 permil.</p>
<p>$$ \delta_1 - \delta_2 = (1+\delta_2)\, \epsilon $$
$$ \epsilon = -\frac{\delta_2}{1+\delta_2} $$</p>
<p>If we take phase 1 to be the liquid water and phase 2 to be the water vapor we
have</p>
<p>$$ \epsilon = \frac{0.01}{0.99} = 0.010101... $$</p>
<p>If we take phase 2 to be liquid water and phase 1 to be the water vapor we have</p>
<p>$$ \epsilon = \frac{0.01}{1} = 0.01 $$</p>
<h3>Problem 22.</h3>
<p>We know that</p>
<p>$$\delta_0 = 0 = \delta_{vapor}f_{vapor} + \delta_{liquid}(1-f_{vapor})$$</p>
<p>$$\delta_{vapor}f_{vapor} = -\delta_{liquid}(1-f_{vapor})$$</p>
<p>Assuming the experiment occurs at 290K we can use $\delta_{vapor} = -0.01$. It
is also stated in the problem that $f_{vapor} = 0.01$.</p>
<div class="highlight"><pre>def d_source_of_t(epsilon, d_source_0, f_source, t):
    d_sources = d_source_0-epsilon*(1-f_source**t)
    return d_sources


def problem22():
    ntrials = 400
    f_source = 0.99
    d_source_0 = 0
    epsilon = -0.01
    evap = partial(d_source_of_t, epsilon, d_source_0, f_source)
    d_liqs = [evap(t) for t in range(ntrials)]
    d_vaps = [d_liq + epsilon for d_liq in d_liqs]

    plt.figure(figsize=(12,8))
    plt.title(&quot;Change in $\delta^{18}\mathrm{O}$ over iterations of evaporation at 290K,\n&quot;
              &quot;relative to $\delta^{18}\mathrm{O}$ of initial liquid water&quot;)
    plt.plot(range(ntrials), d_vaps)
    plt.plot(range(ntrials), d_liqs)
    plt.ylabel(&quot;$\delta^{18}\mathrm{O}$&quot;)
    plt.xlabel(&quot;Timesteps&quot;)
    plt.text(40, 0.003, &quot;liquid water&quot;)
    plt.text(60, -0.006, &quot;water vapor&quot;)

problem22()
</pre></div>


<p><img alt="png" src="images/ch1_files/ch1_52_0.png" /></p>
<p>We see that as time goes on the water vapor asymptotically approaches
0 permil relative to the initial liquid. This fits with our intuition
- as the liquid water all turns into water vapor, the water vapor
comes to represent all of the initial water. Additionally since less
and less water is changing phase in a given time period, the change in
isotopic composition also slows down as time goes on.</p>
<h3>Problem 23.</h3>
<p>We have two lakes, separated by mountains. Water evaporates from the
first lake, goes over the mountain into the second lake. As the water
goes over the mountain some of it condenses out, so the water that
makes it to the second lake is lighter.</p>
<p>In part a, we calculate the magnitude of the preference.</p>
<p>In part b, we see how this preference affects the
$\delta^{18}\mathrm{O}$ of the different lakes as a function of
transferred volume.</p>
<p>In part c, we add in a flow of water from the second lake to the first
lake to offset the evaporation from the first lake. We then see how
the system equilibrates.</p>
<div class="highlight"><pre>def d_source_of_frac(func, frac_gone, resolution=0.01):
    frac_remaining = 1 - frac_gone
    final_time = log(frac_remaining, (1-resolution))
    return func(final_time)


def d_target(d_source_0, d_source, source_remaining):
    return (d_source_0 - source_remaining*d_source) / (1-source_remaining)


def problem23a(ntrials, verbose=False):
    f_source = 0.99
    d_source_0 = -0.01
    epsilon = 0.01
    condense = partial(d_source_of_t, epsilon, d_source_0, f_source)
    d_vaps = [condense(t) for t in range(ntrials)]
    d_liqs = [d_vap + epsilon for d_vap in d_vaps]
    if verbose: 
        print(&quot;After {} timesteps the vapor&#39;s ratio of O18 is {:.2f} permil relative&quot;
              &quot; to that of the lake.&quot;.format(ntrials, d_vaps[-1]*1000))
    return d_vaps[-1]


def problem23b(mountain_steps, remaining_lake1 = 0.75, verbose=False):
    frac_evap = 0.01

    ntrials = 500
    f_lake2 = 0.99**mountain_steps * frac_evap
    f_lake1 = 1 - f_lake2
    f_source = f_lake1
    d_source_0 = 0
    epsilon = problem23a(mountain_steps, verbose=verbose)
    travel_over_mtn = partial(d_source_of_t, epsilon, d_source_0, f_source)
    # fracs is fractions of total that have been moved to lake2
    # thus 1-frac is the fraction remaining in lake1
    fracs = np.linspace(0, 0.99, 100)
    d_lake1s = [d_source_of_frac(travel_over_mtn, frac) for frac in fracs]
    d_lake2s = [d_target(d_source_0, d_lake1, 1-frac)
                for frac, d_lake1 in zip(fracs, d_lake1s)]

    d_lake1_25 = d_source_of_frac(travel_over_mtn, 1-remaining_lake1)
    d_lake2_25 = d_target(d_source_0, d_lake1_25, remaining_lake1)

    result = {&quot;fracs&quot;: fracs,
              &quot;d_lake1s&quot;: d_lake1s, 
              &quot;d_lake2s&quot;: d_lake2s,
              &quot;d_lake1_25&quot;: d_lake1_25,
              &quot;d_lake2_25&quot;: d_lake2_25,
              &quot;evap_epsilon&quot;: epsilon}
    return result

def problem23c(d_lake1_25, d_lake2_25, evap_epsilon, **kwargs):
    f_12 = 0.99  # prop. of lake 1 remaining after some goes to lake 2
    d_lake1s = [d_lake1_25]
    d_lake2s = [d_lake2_25]
    for n in range(250):
        d_lake1_n = d_source_of_t(evap_epsilon, d_lake1s[-1], f_12, 1)
        # now we know isotopic composition of lake2
        d_lake2_n = d_target(0, d_lake1_n, 0.75)
        # now we find the isotopic composition of lake1 which is basically
        # a weighted average
        d_lake1_n = f_12 * d_lake1_n + (1- f_12) * d_lake2_n
        d_lake1s.append(d_lake1_n)
        d_lake2s.append(d_lake2_n)

    return d_lake1s, d_lake2s


def problem23():
    lake_init_state_50 = problem23b(50, verbose=True)
    lake_init_state_75 = problem23b(75, verbose=True)

    plt.figure(figsize=(12,8))
    plt.plot(lake_init_state_50[&quot;fracs&quot;], lake_init_state_50[&quot;d_lake1s&quot;])
    plt.text(0.3, 0.005, &quot;Lake 1&quot;)
    plt.plot(lake_init_state_50[&quot;fracs&quot;], lake_init_state_50[&quot;d_lake2s&quot;])
    plt.text(0.6, -0.005, &quot;Lake 2&quot;)
    plt.title(&quot;$\delta^{18}\mathrm{O}$ of lakes 1 and 2 vs. \n&quot;
              &quot;fraction of lake 1 transferred to lake 2&quot;)
    plt.ylabel(&quot;$\delta^{18}\mathrm{O}$&quot;)
    plt.xlabel(&quot;Fraction of lake 1 in lake 2&quot;)

    d_lake1s_50, d_lake2s_50 = problem23c(**lake_init_state_50)
    d_lake1s_75, d_lake2s_75 = problem23c(**lake_init_state_75)

    plt.figure(figsize=(12,8))
    plt.plot(list(range(251)), d_lake1s_50)
    plt.text(50, 0.0025, &quot;Lake 1, short mountain&quot;)
    plt.plot(list(range(251)), d_lake2s_50)
    plt.text(50, -0.0095, &quot;Lake 2, short mountain&quot;)
    plt.plot(list(range(251)), d_lake1s_75)
    plt.text(5, 0.0035, &quot;Lake 1, tall mountain&quot;)
    plt.plot(list(range(251)), d_lake2s_75)
    plt.text(5, -0.011, &quot;Lake 2, tall mountain&quot;)
    plt.title(&quot;$\delta^{18}\mathrm{O}$ of lakes 1 and 2 vs. \n&quot;
              &quot;time&quot;)
    plt.ylabel(&quot;$\delta^{18}\mathrm{O}$&quot;)
    plt.xlabel(&quot;time&quot;)
    print(d_lake1s_50[-1], d_lake2s_50[-1], d_lake1s_75[-1], d_lake2s_75[-1])



problem23()

After 50 timesteps the vapor&#39;s ratio of O18 is -13.89 permil relative to that of the lake.
After 75 timesteps the vapor&#39;s ratio of O18 is -15.25 permil relative to that of the lake.
0.003333277271129784 -0.010416491472280574 0.003659119816862611 -0.011434749427695661
</pre></div>


<p><img alt="png" src="images/ch1_files/ch1_55_1.png" /></p>
<p><img alt="png" src="images/ch1_files/ch1_55_2.png" /></p>
<p>In the first graph, we see the isotopic ratio as a function of how
much water has moved from one lake to the other. We see that as more
and more water moves to lake 2 it becomes heavier and heavier,
approaching a $\delta^{18}\mathrm{O}$ of near zero. We also see that
the slopes of the lake 1 curve and the lake 2 curve start out
similarly, but diverge near the end as lake 1 dries up.</p>
<p>In the second graph, we see the isotopic ratio as a function of time
after lake 2 begins emptying. Here we have set lake 2 to empty when it
reaches 25% the volume of lake 1. We see that the
$\delta^{18}\mathrm{O}$ approaches about 3.3 permil for Lake 1 and
about -10.4 permil for Lake 2. This process is analogous to
transferring sea water to a glacier. We can think of lake 1 as the sea
water, and lake 2 as the glacier. If all of lake 2 freezes, its
isotopic composition is the same as if it was liquid, so we have the
effect in the first graph. Now if we have lake 2, the glacier, melt at
a rate so that the volume equilibrate when lake 2 has 25% of the total
volume, we get the effect in the second graph.</p>
<p>If we increase the mountain height we increase the difference between
lake 1 and the inflow into lake 2. This causes the equilibrium states
of lake 1 and lake 2 to shift apart, with lake 1 going up to about 3.7
permil and lake 2 going down to about -11.4 permil. This effect is
analogous to that of lowering the temperature of a glacier as both
increase the isotopic difference between the sea water and the newly
transferred glacier/lake 2 water.</p>
<h3>Problem 24.</h3>
<p>Let's take $\delta_a$ to be the initial $\delta^{13}\mathrm{C}$ of the
atmosphere and $\delta_{in}$ to be that of the released carbon. Let's
also use $\delta_a'$ to denote the new $\delta^{13}\mathrm{C}$ of the
atmosphere after the influx of light carbon. Then we have</p>
<p>$$\delta_a' = f_a\delta_a + f_in \delta_{in}$$</p>
<p>Where $f_a$ is the fraction of the total carbon that was original, and
$f_{in}$ is the fraction that makes up the influx of carbon. Since
$f_a + f_{in} = 1$ we have</p>
<p>$$\delta_a' - \delta_a = f_in(\delta_{in} - \delta_a)$$</p>
<p>We can see that $\delta_a$ does have an effecct on $\delta_a' -
\delta_a$. This makes sense - if the atmospheric carbon was strangely
light this release of organic carbon would actually make the
atmospheric carbon heavier.</p>
<p>However, if we assume the atmosphere hasn't changed much since the
organic carbon was plants we can assume that the $\delta_{in}$ is -25
permil relative to $\delta_a$ and we can set $\delta_a=0$. So what
matters is really the relative difference between $\delta_{in}$ and
$\delta_a$.</p>
<div class="highlight"><pre>def problem24(initcarbon, d_in, influx_amt = 700, d_a = 0):
    f_a = initcarbon / (700 + initcarbon)
    f_in = 700 / (700 + initcarbon)
    Dd = f_in * (d_in - d_a)
    print(&quot;When {} Gt of carbon with dC13 of {:.2f} permil is released into an atmosphere \n&quot;
          &quot;containing {} Gt carbon with dC13 of {:.2f} permil, the dC13 of the atmosphere \n&quot;
          &quot;changes by {:.2f} permil.&quot;.format(influx_amt,
                                         d_in*1000.,
                                         initcarbon,
                                         d_a*1000.,
                                         Dd*1000.))

problem24(700, -0.025)
problem24(1400, -0.025)
problem24(700, -0.050)
problem24(70000, -0.025, influx_amt=7000)


When 700 Gt of carbon with dC13 of -25.00 permil is released into an atmosphere 
containing 700 Gt carbon with dC13 of 0.00 permil, the dC13 of the atmosphere 
changes by -12.50 permil.
When 700 Gt of carbon with dC13 of -25.00 permil is released into an atmosphere 
containing 1400 Gt carbon with dC13 of 0.00 permil, the dC13 of the atmosphere 
changes by -8.33 permil.
When 700 Gt of carbon with dC13 of -50.00 permil is released into an atmosphere 
containing 700 Gt carbon with dC13 of 0.00 permil, the dC13 of the atmosphere 
changes by -25.00 permil.
When 7000 Gt of carbon with dC13 of -25.00 permil is released into an atmosphere 
containing 70000 Gt carbon with dC13 of 0.00 permil, the dC13 of the atmosphere 
changes by -0.25 permil.
</pre></div>


<p>We see that in our simulation of the PETM we have underestimated the
amount of lightening by a factor of five. Assuming the masses of the
carbon flows given in the book are not wildly inaccurate, this
difference must be mostly accounted for by the assumption that the
$\delta^{13}\mathrm{C}$ of carbonates in the ocean mirrors the shift
in $\delta^{13}\mathrm{C}$ of the entire carbon pool, and that the
carbon is distributed evenly throughout the carbon pool. For example,
if the lighter carbon was quickly absorbed into the oceans and
deposited, the carbonates would be lighter than the pool as a whole.</p>
<h3>Problem 25.</h3>
<p>We look at an atmosphere that has a $\delta^{13}\mathrm{C}$ of -6
permil and introduce photosynthesis. We compare the effect of
photosynthesis without any additional outgassing to compensate for
organic burial to that of photosynthesis with outgassing.</p>
<div class="highlight"><pre><span class="s-Atom">def</span> <span class="nf">problem25</span><span class="p">(</span><span class="s-Atom">outgas_rate</span><span class="p">,</span> <span class="s-Atom">ntimesteps</span><span class="p">,</span> <span class="s-Atom">photosynthesis_rate</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span><span class="s-Atom">:</span>
    <span class="s-Atom">#</span> <span class="s-Atom">outgas</span> <span class="s-Atom">rate</span> <span class="s-Atom">as</span> <span class="s-Atom">a</span> <span class="s-Atom">fraction</span> <span class="s-Atom">of</span> <span class="s-Atom">initial</span> <span class="s-Atom">atmospheric</span> <span class="s-Atom">mass</span>
    <span class="s-Atom">photosynthesis_rate</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="s-Atom">d_outgas</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.006</span>
    <span class="s-Atom">d_org</span> <span class="o">=</span> <span class="s-Atom">d_outgas</span> <span class="o">-</span> <span class="mf">0.025</span>
    <span class="s-Atom">d_atms</span> <span class="o">=</span> <span class="p">[</span><span class="s-Atom">d_outgas</span><span class="p">]</span>
    <span class="s-Atom">d_orgs</span> <span class="o">=</span> <span class="p">[</span><span class="s-Atom">d_org</span><span class="p">]</span>
    <span class="s-Atom">for</span> <span class="s-Atom">t</span> <span class="s-Atom">in</span> <span class="nf">range</span><span class="p">(</span><span class="s-Atom">ntimesteps</span><span class="p">)</span><span class="s-Atom">:</span>
        <span class="s-Atom">d_atm_t</span> <span class="o">=</span> <span class="nf">d_source_of_t</span><span class="p">(</span><span class="o">-</span><span class="mf">0.025</span><span class="p">,</span> <span class="s-Atom">d_outgas</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="s-Atom">photosynthesis_rate</span><span class="p">,</span> <span class="s-Atom">t</span><span class="p">)</span>
        <span class="s-Atom">#outgassing</span> <span class="s-Atom">adjustment</span>
        <span class="s-Atom">d</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="s-Atom">outgas_rate</span><span class="p">)</span> <span class="o">*</span> <span class="s-Atom">d_atm_t</span> <span class="o">+</span> <span class="s-Atom">outgas_rate</span> <span class="o">*</span> <span class="s-Atom">d_outgas</span>
        <span class="s-Atom">d_atms</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s-Atom">d</span><span class="p">)</span>

        <span class="s-Atom">d_org_t</span> <span class="o">=</span> <span class="s-Atom">d_atms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.025</span>
        <span class="s-Atom">d_orgs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="s-Atom">d_org_t</span><span class="p">)</span>
    <span class="s-Atom">return</span> <span class="s-Atom">d_atms</span><span class="p">,</span> <span class="s-Atom">d_orgs</span>

<span class="s-Atom">timesteps</span> <span class="o">=</span> <span class="mi">250</span>
<span class="s-Atom">d_atms_no_out</span><span class="p">,</span> <span class="s-Atom">d_orgs_no_out</span> <span class="o">=</span> <span class="nf">problem25</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s-Atom">timesteps</span><span class="p">)</span>
<span class="s-Atom">d_atms</span><span class="p">,</span> <span class="s-Atom">d_orgs</span> <span class="o">=</span> <span class="nf">problem25</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="s-Atom">timesteps</span><span class="p">,</span> <span class="s-Atom">photosynthesis_rate</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>

<span class="s-Atom">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="s-Atom">figsize=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="s-Atom">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="err">&quot;$</span><span class="s-Atom">\delta^</span><span class="p">{</span><span class="mi">13</span><span class="p">}</span><span class="s-Atom">\mathrm</span><span class="p">{</span><span class="nv">C</span><span class="p">}</span><span class="err">$</span> <span class="s-Atom">of</span> <span class="s-Atom">atmospheric</span> <span class="s-Atom">and</span> <span class="s-Atom">organic</span> <span class="s-Atom">carbon</span> <span class="s-Atom">vs</span><span class="p">.</span> <span class="s-Atom">years</span><span class="s2">&quot;)</span>
<span class="s2">plt.xlabel(&quot;</span><span class="nf">time</span><span class="p">(</span><span class="s-Atom">years</span><span class="p">)</span><span class="s2">&quot;)</span>
<span class="s2">plt.ylabel(&quot;</span><span class="err">$</span><span class="s-Atom">\delta^</span><span class="p">{</span><span class="mi">13</span><span class="p">}</span><span class="s-Atom">\mathrm</span><span class="p">{</span><span class="nv">C</span><span class="p">}</span><span class="err">$</span> <span class="p">(</span><span class="s-Atom">permil</span><span class="p">)</span><span class="s2">&quot;)</span>
<span class="s2">plt.plot(range(timesteps), d_atms_no_out[:-1])</span>
<span class="s2">plt.text(5, 0.006, &quot;</span><span class="s-Atom">atmosphere</span><span class="p">,</span> <span class="s-Atom">no</span> <span class="s-Atom">outgassing</span><span class="s2">&quot;)</span>
<span class="s2">plt.plot(range(timesteps), d_orgs_no_out[:-1])</span>
<span class="s2">plt.text(5, -0.019, &quot;</span><span class="s-Atom">organic</span> <span class="s-Atom">carbon</span><span class="p">,</span> <span class="s-Atom">no</span> <span class="s-Atom">outgassing</span><span class="s2">&quot;)</span>
<span class="s2">plt.plot(range(timesteps), d_atms[:-1])</span>
<span class="s2">plt.text(37, 0, &quot;</span><span class="s-Atom">atmosphere</span><span class="p">,</span> <span class="s-Atom">outgassing</span><span class="s2">&quot;)</span>
<span class="s2">plt.plot(range(timesteps), d_orgs[:-1])</span>
<span class="s2">plt.text(37, -0.026, &quot;</span><span class="s-Atom">organic</span> <span class="s-Atom">carbon</span><span class="p">,</span> <span class="s-Atom">outgassing</span><span class="err">&quot;</span><span class="p">)</span>






<span class="o">&lt;</span><span class="s-Atom">matplotlib</span><span class="p">.</span><span class="s-Atom">text</span><span class="p">.</span><span class="nv">Text</span> <span class="s-Atom">at</span> <span class="mh">0x2b6a33765748</span><span class="o">&gt;</span>
</pre></div>


<p><img alt="png" src="images/ch1_files/ch1_61_1.png" /></p>
<p>If we were to take a core sample we would find a similar curve to
this, but it would be compressed into a log scale on the X
axis. because it takes longer to lay down a certain depth of organic
carbon as less and less carbon is being taken out of the atmosphere.</p>
<p>We see that the outgassing has only a slight downwards effect on the
photosynthesis effect as a whole. This isn't affected by the total
amount of carbon in the system - however, it is affected by the rate
of outgassing required. Higher burial rate</p>
<p>The mass of $\mathrm{O}_2$ in the atmosphere increases without bound
in the outgassing case. This does not happen because there are
critters like us that turn it back into CO2.</p>
<h3>Problem 26.</h3>
<p>We have some benthic foram data that shows the historical levels of
$\delta^{13}\mathrm{C}$ and $\delta^{18}\mathrm{O}$. We would like to
see how this data matches up with the mechanisms we modeled in
problems 23 and 25.</p>
<div class="highlight"><pre>def d13C_by_f_org(f_org):
    &quot;&quot;&quot;Get equilibrium d13C of atmosphere by burial rate, assuming equilibrium
    between photosynthesis and burial.
    &quot;&quot;&quot;
    outgas_d = -0.006
    f_carb = 1 - f_org
    return (outgas_d + f_carb * (-0.025)) * 1000


def d18O_by_ice_volume(ice_volume):
    &quot;&quot;&quot;Get equilibrium d13O of atmosphere by burial rate, assuming equilibrium
    between photosynthesis and burial.
    &quot;&quot;&quot;
    ocean_volume = 1 - ice_volume
    mountain_steps = 50
    init_state = problem23b(mountain_steps, ocean_volume)
    timesteps = 1000
    d_oceans, d_glaciers = problem23c(**init_state)

    return (1-ice_volume) * d_glaciers[-1] * 1000

def problem26():
    benthic = pd.read_csv(&quot;data/Chapter1Data/marineCores/BenthicTropPacific.txt&quot;,
                          skiprows=41, 
                          delim_whitespace=True)
    d13C = benthic[&quot;d13Cforams-b&quot;]
    d13Crange = max(d13C) - min(d13C)
    d13Cstddev = benthic.std(axis=0)[&quot;d13Cforams-b&quot;]
    print(&quot;d13C varied by {:.2} permil and the stddev was {:.2} permil.&quot;
          .format(d13Crange, d13Cstddev))
    burial_space = np.linspace(0, 1, 100)
    d13C_burial = [d13C_by_f_org(r) for r in burial_space]
    plt.figure(figsize=(12, 8))
    plt.title(&quot;$\delta^{13}\mathrm{C}$ of carbonates vs. burial rate&quot;)
    plt.plot(burial_space, d13C_burial)
    d18O = benthic[&quot;d18Oforams-b&quot;]
    d18Orange = max(d18O) - min(d18O)
    d18Ostddev = benthic.std(axis=0)[&quot;d18Oforams-b&quot;]
    print(&quot;d18O varied by {:.2} permil and the stddev was {:.2} permil.&quot;
          .format(d18Orange, d18Ostddev))
    icevol_space = np.linspace(0, 0.999, 50)
    d18O_icevol = [d18O_by_ice_volume(v) for v in icevol_space]
    plt.figure(figsize=(12, 8))
    plt.title(&quot;$\delta^{18}\mathrm{O}$ of the ocean vs. burial rate&quot;)
    plt.plot(icevol_space, d18O_icevol)
    plt.gca().ticklabel_format(useOffset=False)


problem26()


d13C varied by 1.4 permil and the stddev was 0.24 permil.
d18O varied by 2.2 permil and the stddev was 0.38 permil.
</pre></div>


<p><img alt="png" src="images/ch1_files/ch1_64_1.png" /></p>
<p><img alt="png" src="images/ch1_files/ch1_64_2.png" /></p>
<p>We see that we would need to vary the burial rate by about 5% of the
total volume of the atmosphere to achieve the maximum variation in
$\delta^{13}\mathrm{C}$ we see historically. We also see that the
higher the burial rate, the higher the $\delta^{13}\mathrm{C}$ of
carbonates. This makes sense as the higher the burial rate, the more
light carbon is taken out of the atmosphere, causing the remaining
carbon to be relatively heavy.</p>
<p>We also see that we would need to vary the fraction of the oceans
locked in ice by almost 20% to achieve the maximum variation in
historical $\delta^{18}\mathrm{O}$. We also see that as more of the
oceans freeze, the oceans have more $\delta^{18}\mathrm{O}$. This
makes sense as glaciers tend to be isotopically lighter than the
oceans.</p>
<p>In an earlier problem we assumed a burial rate of around 1% - this
seems to indicate that a 5% fluctuation is very large, whereas a 20%
fluctuation in the ice volume seems more plausible, and wins my vote for
"more plausible extreme condition."</p>
  </div><!-- /.entry-content -->
  <a href="/archives.html">< back</a>
</section>
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
  </div>
</body>
</html>